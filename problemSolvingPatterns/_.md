# Common Problem solving patterns

## Frequency Counter( Anytime comparing pieces of data)

Used mainly when comparing values of multiple inputs. This pattern uses **Objects** or **sets** to collect values/frequencies of values.

This pattern can often be used to avoid the need for nested loops or **O(n^2)** operations with **arrays/strings**.

### Example problem

Write a function called **same**, which accepts two arrays. The function should return true if every value in the array has it's corresponding
value squared in the second array. The frequency of the values must be the same

### Solutions

### Brute force

func getSameSquaredValue(arr1, arr2){
    <!-- check if they have same length -->
    if(arr1.length !== arr2.length){
        return false;
    }
    <!-- loop through the first array -->
    for(let i =0; i < arr1.length; i++){
        let correctIndex = arr2.indexOf(arr1[i] ** 2);
         if(correctIndex === -1){
            return false;
         }
         arr2.splice(correctIndex,1)
    }
    return true;
}

### Optimized

func getSameSquaredValue(arr1, arr2){
    <!-- compare length -->
    if(arr1.length !== arr2.length){
        return false;
    }
    let counter1 = {}
    let counter2 = {}

    <!-- loop through the arrays separately -->

    for (let val of arr1){
        counter1[val] = (counter1[val] || 0) + 1;
    }

    for (let val of arr2){
        counter2[val] = (counter2[val] || 0) + 1;
    }

    for(let key in counter1){
        if(!(key ** 2 in counter2)){
            return false;
        }
        if(counter2[key ** 2] !== counter1[key]){
            return false
        }
    }
    return true;
}

### Anagram challenge

#### Frequency Counter - validAnagram

Given two strings, write a function to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.

Examples:

```
    validAnagram('', '') // true
    validAnagram('aaz', 'zza') // false
    validAnagram('anagram', 'nagaram') // true
    validAnagram("rat","car") // false) // false
    validAnagram('awesome', 'awesom') // false
    validAnagram('amanaplanacanalpanama', 'acanalmanplanpamana') // false
    validAnagram('qwerty', 'qeywrt') // true
    validAnagram('texttwisttime', 'timetwisttext') // true
```

Note: You may assume the string contains only lowercase alphabets.

Time Complexity - O(n)

### Solution

func validAnagram(str1, str2){
    <!-- first check the length to confirm they have the same length -->
    if(str1.length !== str2.length){
        return false;
    }

    let frequency1={}
    let frequency2={}

    <!-- loop through the strings -->
    for(let val of str1){
        frequency1[val] = (frequency1[val] || 0) + 1;
    }

    for(let val of str2){
        frequency2[val] = (frequency2[val] || 0) + 1;
    }

    for(let key in frequency1){
        if(!(key in frequency2)){
            return false;
        }
        if(frequency2[key] !== frequency1[key]){
            return false
        }
    }
    return true;
}

### Unique Number of Occurrences

Given an array of integers **arr**, return **true** if the number of occurrences of each value in the array is **unique** or **false** otherwise.

Example 1:

Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

Example 2:

Input: arr = [1,2]
Output: false

Example 3:

Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true

Constraints:

    1 <= arr.length <= 1000
    -1000 <= arr[i] <= 1000

#### Solution using Frequency Counter

func uniqueOccurrences(arr){
    <!-- check arr length -->
    if(arr.length === 0){
        return false;
    }

<!-- define the two frequencies -->
    let frequency1 = {}
    let uniqueFrequency = {}

    <!-- loop through the array to create a hash map -->
    for(let val of arr){
        frequency1[val] = (frequency1[val] || 0) + 1
    }

    <!-- iterate through the hash map to identify unique frequencies -->
    for(let key in frequency1){
        if(uniqueFrequency[frequency1[key]]){
            return false
        }
        uniqueFrequency[frequency1[key]] = 1
    }

    return true;
}

### Count Elements With Maximum Frequency

You are given an array nums consisting of positive integers.

Return the total frequencies of elements in nums such that those elements all have the maximum frequency.

The frequency of an element is the number of occurrences of that element in the array.

#### SOLUTION

func countElementsWithMaxFreq(nums){
    <!-- check array length -->
    if(nums.length === 0){
        return 0;
    }

    <!-- create a hash map from the array to get frequencies -->
    let frequency1 = {}

    <!-- loop through the array to fill the hash map -->
    for(let num of nums){
        frequency1[num] = (frequency1[num] || 0) + 1;
    }

    <!-- get max frequency from the hash map -->
    let maxFreq = Math.max(...Object.values(frequency1))

    <!-- then now find the sum of those max frequencies inside the object -->
    let totalMaxFreq = 0;
    <!-- loop throgh the newly formed array of max frequencies -->
    let maxVals = Object.values(frequency1)
    for(let val of maxVals){
        <!-- check if val is equal to maxFreq -->
        if(val === maxFreq){
            totalMaxFreq += val
        }
    }
    return totalMaxFreq;
}

## Multiple Pointers(Solving problems with minimal space complexity)

Involves moving from one direction to another from both sides of an array, list or a string.

### Example Multiple Pointers problem(pointer on both ends)

Write a function call sumZero which accepts a sorted array of integers. The function should find the first pair where the sum
is 0. Return an array that includes both values that sum to zero or undefined if the pair does not exist.

#### Brute force solution(for loop)

func sumZero(intArr){
    if(intArr.length === 0){
        return undefined;
    }
for(let i = 0; i < intArr.length; i++){
    for(let j = i + 1; j < intArr.length; j++){
        let sum = intArr[i] + intArr[j]
        if(sum === 0){
            return [intArr[i], intArr[j]]
        }
    }
}
return undefined;
}

#### Optimized Solution(multiple pointers/two pointers)(pointer on both ends)

func sumZero(intArr){
    if(intArr.length === 0){
        return undefined;
    }
<!-- define the pointers -->
let leftPointer = 0;
let rightPointer = intArr.length - 1;
<!-- use while loop to check if left is less then the right as it should be since we are working with a sorted array -->
while(leftPointer < rightPointer){
    let sum = intArr[leftPointer] + intArr[rightPointer]
    if(sum === 0){
        return [intArr[leftPointer], intArr[rightPointer]]
    }
    else if(sum > 0){
        rightPointer --;
    }else{
        leftPointer ++;
    }
}
}

### Example Multiple Pointers problem(pointers on one ends)

Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

    countUniqueValues([1,1,1,1,1,2]) // 2
    countUniqueValues([1,2,3,4,4,4,7,7,12,12,13]) // 7
    countUniqueValues([]) // 0
    countUniqueValues([-2,-1,-1,0,1]) // 4

Time Complexity - O(n)
Space Complexity - O(n)

<!-- Brute force solution using a nested loop -->

func countUniqueValues(arr){
    <!-- check length of array -->
    if(arr.length === 0){
        return 0
    }
    let result = 0;

    <!-- loop through the array -->
    for(let i = 0; i < arr.length; i++){ 
        for(let j = i + 1; j < arr.length; j++){
            if(arr[i] !== arr[j]){
                result ++
            }     
        }
    }

    return result;
}

<!-- optimized solution using multiple pointers -->
func countUniqueValues(arr){
     if(arr.length === 0){
        return 0;
    }
    let firstPointer = 0;
    for(let secondPointer = firstPointer + 1; secondPointer < arr.length; secondPointer++){
        if(arr[firstPointer] !== arr[secondPointer]){
            firstPointer ++;
            arr[firstPointer] = arr[secondPointer]
        }
    }
    return firstPointer + 1;
}

## Sliding Window Pattern

This pattern involves creating a window which can either be an array or number from one position to another.
Depending on certain conditions, the window either increases or closes(and a new window is created)

This pattern is very useful for keeping track of a subset of data in array/string etc.

### Find the maxSubarraySum: maxSubarraySum([2,6,9,2,1,8,5,6,3],3)

Problem: Given an array and an integer K, find the maximum sum of any subarray of size K.

<!-- BRUTE FORCE SOLUTION  O(n^2)-->
func maxSubarraySum(arr, target){
    <!-- first check to see that the length of the array is not less than the subarray sum -->
    if(arr.length <  target){
        return null
    }
    <!-- initialize the maxSum to zero -->
    let maxSum = 0;
    <!-- loop through the entire array first -->
    for(let i = 0; i <= arr.length - target; i++){
        <!-- initialize the current sum of the sub array to zero -->
        let currentSum = 0
        <!-- loop through the formed sub array -->
        for(let j = i; j < i + target; j++){
            currentSum += arr[j]
        }
        maxSum = Math.max(maxSum, curremtSum)
    }

    return maxSum;
}

<!-- OPTIMIZED SOLUTION  O(n)-->
func maxSubarraySum(arr, target){
    <!-- check arr length against the target  -->
    if(arr.length < target){
        return null;
    }

    <!-- initialize temporary sum -->
    let tempSum = 0;
    <!-- loop over the array to get the first sum -->
    for(let i = 0; i < arr.length; i++){
        tempSum += arr[i]
    }

    <!-- initialize the maxSum and equate it to tempSum-->

    let maxSum = tempSum;
    <!-- loop ove the subarray to find another sum -->
    for(let i = target; i <= arr.length; i++){
        tempSum = tempSum - arr[i - target] + arr[i]
        maxSum = Math.max(maxSum, tempSum)
    }
    return maxSum;
}

### SECOND PROBLEM

Example 2: Longest Substring Without Repeating Characters
Problem: Given string **"abcabcbb"**, find length of longest **substring** without repeating characters.

func lengthOfLongestSubstring(s){
    let left = 0;
    let maxLength = 0;
    let charSet = new Set();

    <!-- loop through the string -->
    for(let i = 0; i < a.length; i++){
        while(charSet.has(s[i])){
            charSet.delete(s[left])
            left++
        }
        charSet.add(s[i])
        maxLength = Math.max(maxLength, i - left + 1)
    }
    return maxLength;
}