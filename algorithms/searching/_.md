<!-- Searching Algorithm(Linear Search)  -->

<!-- LINEAR SEARCH -->
<!-- This involves iterating through a list/array to find an item. Moving from one item to another to find the target item. -->
<!-- JavaScript is doing this search via some of its short methods like (indexOf, includes, find, findIndex). -->
<!-- These methods uses linear search behind the scene to provide the required results and fullfil their operations. -->

<!-- EXAMPLE OF A LINEAR SEARCH: BIG-O = O(n)-->

<!-- Write a function called linearSearch which accepts an array and a value, and returns the index at which the value exists. If the value does not exist in the array, return -1.

Don't use indexOf to implement this function!

Examples:

    linearSearch([10, 15, 20, 25, 30], 15) // 1
    linearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 4) // 5
    linearSearch([100], 100) // 0
    linearSearch([1,2,3,4,5], 6) // -1
    linearSearch([9, 8, 7, 6, 5, 4, 3, 2, 1, 0], 10) // -1
    linearSearch([100], 200) // -1 -->

<!-- SOLUTION -->

function findItemIndex(arr, target){
    <!-- FOR LOOP SOLUTION -->
    <!-- edge case -->
    if(arr.length === 0){
        return -1
    }

    <!-- loop through the array to check -->
    for(let i =0; i < arr.length; i++){
        if(arr[i] === target){
            return i
        }
    }
    return -1;
}

<!-- BINARY SEARCH -->
<!-- Binary search is a much faster form of search. Rather than eliminating one element at a time, you can eliminate half of the remaining 
elements at a time -->
<!-- The only thing you have to know if that Binary Search only works on sorted array. -->

<!-- EXAMPLE OF BINARY SEARCH: BIG-O = O(log n)  -->

<!-- Write a function called binarySearch which accepts a sorted array and a value and returns the index at which the value exists. Otherwise, return -1.

This algorithm should be more efficient than linearSearch - you can read how to implement it here - https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search and here - https://www.topcoder.com/community/data-science/data-science-tutorials/binary-search/

Examples:

    binarySearch([1,2,3,4,5],2) // 1
    binarySearch([1,2,3,4,5],3) // 2
    binarySearch([1,2,3,4,5],5) // 4
    binarySearch([1,2,3,4,5],6) // -1
    binarySearch([
      5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 
      40, 44, 64, 79, 84, 86, 95, 96, 98, 99
    ], 10) // 2
    binarySearch([
      5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 
      40, 44, 64, 79, 84, 86, 95, 96, 98, 99
    ], 95) // 16
    binarySearch([
      5, 6, 10, 13, 14, 18, 30, 34, 35, 37, 
      40, 44, 64, 79, 84, 86, 95, 96, 98, 99
    ], 100) // -1 -->

<!-- SOLUTION -->

function binarySearch(arr, val){
    if(arr.length === 0){
        return -1
    }
    <!-- declare the pointers -->
    let leftPointer = 0;
    let rightPointer = arr.length - 1;
    let middlePointer = Math.floor((leftPointer + rightPointer) / 2);

    while(leftPointer < rightPointer && arr[middlePointer] !== val){
        if(val < arr[middlePointer]){
            rightPointer = middlePointer - 1; 
        }else{
            leftPointer = middlePointer + 1;
        }
        <!-- get the new middle -->
        middlePointer = Math.floor((leftPointer + rightPointer) / 2)
    } 

    if(arr[middlePointer] === val){
        return middlePointer
    }else{
        return -1
    }
}

<!-- STRING SEARCH -->
function stringSearch(str1, str2){
    <!-- check str1 length to ensure it islonger than str2 -->
    if(str1.length < str2.length){
        return 0
    }

    let counter = 0

    <!-- loop over the first string-->
    for(let i = 0; i < str1.length; i++){
        for(let j = 0; j < str2.length; j++){
            if(str1[i + j] !== str2[j]){
                break
            }
            if(j === str2.length - 1){
                counter++
            }
        }
    }
    return counter;
}

<!-- PROBLEM 1  -->
Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array. 
<!-- Example 1: -->
Input: nums = [3,0,1]
Output: 2
Explanation:
n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums.

<!-- Example 2: -->
Input: nums = [0,1]
Output: 2
Explanation:
n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums.

<!-- Example 3: -->
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
Explanation:
n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums.

<!-- Constraints: -->
    n == nums.length
    1 <= n <= 104
    0 <= nums[i] <= n
    All the numbers of nums are unique.
Follow up: Could you implement a solution using only **O(1)** extra space complexity and **O(n)** runtime complexity?

<!-- SOLUTION -->
function missingNumber(nums){
    <!-- find n first -->
    let n = nums.length;
    <!-- initialize sum of current available items -->
    let currentSum = 0;
    <!-- find expected total sum -->
    let expectedTotalSum = n * (n + 1) /2;

    <!-- loop over the existing array to update current sum -->
    for(let i = 0; i <  nums.length; i++){
        currentSum += nims[i]
    }

    return expectedTotalSum - currentSum;
}

<!-- PROBLEM 2 -->
Given two integer arrays nums1 and nums2, return an array of their

. Each element in the result must be unique and you may return the result in any order.

<!-- Example 1: -->
Input: nums1 = [1,2,2,1], nums2 = [2,2]
Output: [2]

<!-- Example 2: -->
Input: nums1 = [4,9,5], nums2 = [9,4,9,8,4]
Output: [9,4]
Explanation: [4,9] is also accepted.

<!-- Constraints: -->

    1 <= nums1.length, nums2.length <= 1000
    0 <= nums1[i], nums2[i] <= 1000

<!-- SOLUTION -->

<!-- brute force solution using a set-->

function findIntersection(nums1, num2){
    <!-- initialize a new set  -->
    let mySet = new Set();

    <!-- use for loop to loop through the arrays -->
    for(let i = 0; i < nums1.length; i++){
        for(letj = 0; j < nums2.length; j++){
            if(nums1[i] === nums2[j]){
                mySet.add(nums1[i])
            }
        }
    }
    return Array.from(mySet)
}

<!-- optimized solution using the frequency counter pattern -->

function findIntersection(nums1, num2){
    <!-- initialize the frequencies -->

    let frequency1 = {};
    let frequency2 = {}
    let resultArr = []

    <!-- loop through the arrays to create hash maps -->
    for(let val of nums1){
        frequency1[val] = (frequency1[val] || 0) + 1;
    }

    for(let val of nums2){
        frequency2[val] = (frequency2[val] || 0) + 1;
    }

    <!-- compare the keys in the two frequency objects -->
    for(let key in ferquency1){
        if(key in ferquency2){
            resultArr.push(Number(key))
        }
    }

    return resultArr;
}
