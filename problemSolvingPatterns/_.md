# Common Problem solving patterns

## Frequency Counter( Anytime comparing pieces of data)

Used mainly when comparing values of multiple inputs. This pattern uses **Objects** or **sets** to collect values/frequencies of values.

This pattern can often be used to avoid the need for nested loops or **O(n^2)** operations with **arrays/strings**.

### Example problem

Write a function called **same**, which accepts two arrays. The function should return true if every value in the array has it's corresponding
value squared in the second array. The frequency of the values must be the same

### Solutions

### Brute force

func getSameSquaredValue(arr1, arr2){
    <!-- check if they have same length -->
    if(arr1.length !== arr2.length){
        return false;
    }
    <!-- loop through the first array -->
    for(let i =0; i < arr1.length; i++){
        let correctIndex = arr2.indexOf(arr1[i] ** 2);
         if(correctIndex === -1){
            return false;
         }
         arr2.splice(correctIndex,1)
    }
    return true;
}

### Optimized

func getSameSquaredValue(arr1, arr2){
    <!-- compare length -->
    if(arr1.length !== arr2.length){
        return false;
    }
    let counter1 = {}
    let counter2 = {}

    <!-- loop through the arrays separately -->

    for (let val of arr1){
        counter1[val] = (counter1[val] || 0) + 1;
    }

    for (let val of arr2){
        counter2[val] = (counter2[val] || 0) + 1;
    }

    for(let key in counter1){
        if(!(key ** 2 in counter2)){
            return false;
        }
        if(counter2[key ** 2] !== counter1[key]){
            return false
        }
    }
    return true;
}

### Anagram challenge

#### Frequency Counter - validAnagram

Given two strings, write a function to determine if the second string is an anagram of the first. An anagram is a word, phrase, or name formed by rearranging the letters of another, such as cinema, formed from iceman.

Examples:

```
    validAnagram('', '') // true
    validAnagram('aaz', 'zza') // false
    validAnagram('anagram', 'nagaram') // true
    validAnagram("rat","car") // false) // false
    validAnagram('awesome', 'awesom') // false
    validAnagram('amanaplanacanalpanama', 'acanalmanplanpamana') // false
    validAnagram('qwerty', 'qeywrt') // true
    validAnagram('texttwisttime', 'timetwisttext') // true
```

Note: You may assume the string contains only lowercase alphabets.

Time Complexity - O(n)

### Solution

func validAnagram(str1, str2){
    <!-- first check the length to confirm they have the same length -->
    if(str1.length !== str2.length){
        return false;
    }

    let frequency1={}
    let frequency2={}

    <!-- loop through the strings -->
    for(let val of str1){
        frequency1[val] = (frequency1[val] || 0) + 1;
    }

    for(let val of str2){
        frequency2[val] = (frequency2[val] || 0) + 1;
    }

    for(let key in frequency1){
        if(!(key in frequency2)){
            return false;
        }
        if(frequency2[key] !== frequency1[key]){
            return false
        }
    }
    return true;
}

### Unique Number of Occurrences

Given an array of integers **arr**, return **true** if the number of occurrences of each value in the array is **unique** or **false** otherwise.

Example 1:

Input: arr = [1,2,2,1,1,3]
Output: true
Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences.

Example 2:

Input: arr = [1,2]
Output: false

Example 3:

Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]
Output: true

Constraints:

    1 <= arr.length <= 1000
    -1000 <= arr[i] <= 1000

#### Solution using Frequency Counter

func uniqueOccurrences(arr){
    <!-- check arr length -->
    if(arr.length === 0){
        return false;
    }

<!-- define the two frequencies -->
    let frequency1 = {}
    let uniqueFrequency = {}

    <!-- loop through the array to create a hash map -->
    for(let val of arr){
        frequency1[val] = (frequency1[val] || 0) + 1
    }

    <!-- iterate through the hash map to identify unique frequencies -->
    for(let key in frequency1){
        if(uniqueFrequency[frequency1[key]]){
            return false
        }
        uniqueFrequency[frequency1[key]] = 1
    }

    return true;
}

## Multiple Pointers(Solving problems with minimal space complexity)

Involves moving from one direction to another from both sides of an array, list or a string.

### Example Multiple Pointers problem(pointer on both ends)

Write a function call sumZero which accepts a sorted array of integers. The function should find the first pair where the sum
is 0. Return an array that includes both values that sum to zero or undefined if the pair does not exist.

#### Brute force solution(for loop)

func sumZero(intArr){
    if(intArr.length === 0){
        return undefined;
    }
for(let i = 0; i < intArr.length; i++){
    for(let j = i + 1; j < intArr.length; j++){
        let sum = intArr[i] + intArr[j]
        if(sum === 0){
            return [intArr[i], intArr[j]]
        }
    }
}
return undefined;
}

#### Optimized Solution(multiple pointers/two pointers)(pointer on both ends)

func sumZero(intArr){
    if(intArr.length === 0){
        return undefined;
    }
<!-- define the pointers -->
let leftPointer = 0;
let rightPointer = intArr.length - 1;
<!-- use while loop to check if left is less then the right as it should be since we are working with a sorted array -->
while(leftPointer < rightPointer){
    let sum = intArr[leftPointer] + intArr[rightPointer]
    if(sum === 0){
        return [intArr[leftPointer], intArr[rightPointer]]
    }
    else if(sum > 0){
        rightPointer --;
    }else{
        leftPointer ++;
    }
}
}

### Example Multiple Pointers problem(pointers on one ends)

Implement a function called countUniqueValues, which accepts a sorted array, and counts the unique values in the array. There can be negative numbers in the array, but it will always be sorted.

    countUniqueValues([1,1,1,1,1,2]) // 2
    countUniqueValues([1,2,3,4,4,4,7,7,12,12,13]) // 7
    countUniqueValues([]) // 0
    countUniqueValues([-2,-1,-1,0,1]) // 4

Time Complexity - O(n)
Space Complexity - O(n)

<!-- Brute force solution using a nested loop -->

func countUniqueValues(arr){
    <!-- check length of array -->
    if(arr.length === 0){
        return 0
    }
    let result = 0;

    <!-- loop through the array -->
    for(let i = 0; i < arr.length; i++){ 
        for(let j = i + 1; j < arr.length; j++){
            if(arr[i] !== arr[j]){
                result ++
            }     
        }
    }

    return result;
}

<!-- optimized solution using multiple pointers -->
func countUniqueValues(arr){
     if(arr.length === 0){
        return 0;
    }
    let firstPointer = 0;
    for(let secondPointer = firstPointer + 1; secondPointer < arr.length; secondPointer++){
        if(arr[firstPointer] !== arr[secondPointer]){
            firstPointer ++;
            arr[firstPointer] = arr[secondPointer]
        }
    }
    return firstPointer + 1;
}
